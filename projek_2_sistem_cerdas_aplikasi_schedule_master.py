# -*- coding: utf-8 -*-
"""Projek 2 Sistem Cerdas Aplikasi Schedule Master

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ttOXwf_4sFGrZu0UkSug5SDGuhKtMBTM
"""

!pip install dash dash-bootstrap-components pandas flask-ngrok plotly

import dash
import dash_bootstrap_components as dbc
from dash import dcc, html
from dash.dependencies import Input, Output, State
import pandas as pd
import plotly.express as px
from flask_ngrok import run_with_ngrok
from flask import Flask

# Initialize the server
server = Flask(__name__)
app = dash.Dash(__name__, server=server, external_stylesheets=[dbc.themes.CYBORG])
run_with_ngrok(server)  # Use ngrok to run the app

# DataFrame to hold the schedule
schedule_df = pd.DataFrame(columns=['Task', 'Date', 'Time', 'Description'])

def add_task(task, date, time, desc):
    global schedule_df
    new_task = pd.DataFrame({
        'Task': [task],
        'Date': [date],
        'Time': [time],
        'Description': [desc]
    })
    schedule_df = pd.concat([schedule_df, new_task], ignore_index=True)

def delete_task(task_name):
    global schedule_df
    schedule_df = schedule_df[schedule_df['Task'] != task_name]

def create_table(dataframe):
    return dbc.Table.from_dataframe(dataframe, striped=True, bordered=True, hover=True)

def create_timeline(dataframe):
    if dataframe.empty:
        return html.Div("No tasks available.")

    dataframe['Datetime'] = pd.to_datetime(dataframe['Date'] + ' ' + dataframe['Time'])
    fig = px.timeline(dataframe, x_start="Datetime", x_end="Datetime", y="Task", color="Task", title="Task Timeline")
    fig.update_yaxes(categoryorder="total ascending")
    return dcc.Graph(figure=fig)

app.layout = dbc.Container([
    # Header
    dbc.Row(dbc.Col(html.H1("üéØ Schedule Master Pro", className="text-center text-light mb-4"), width=12)),

    # Input fields for adding a new task
    dbc.Row([
        dbc.Col(dbc.Input(id="task-input", placeholder="Task name...", type="text"), width=3),
        dbc.Col(dbc.Input(id="date-input", placeholder="Date (YYYY-MM-DD)...", type="date"), width=3),
        dbc.Col(dbc.Input(id="time-input", placeholder="Time (HH:MM)...", type="time"), width=2),
        dbc.Col(dbc.Input(id="desc-input", placeholder="Description...", type="text"), width=3),
        dbc.Col(dbc.Button("Add Task", id="add-task-btn", color="primary", n_clicks=0), width=1)
    ], className="mb-4"),

    # Display the schedule table
    dbc.Row([
        dbc.Col(html.Div(id="schedule-table", children=create_table(schedule_df)), width=12)
    ], className="mb-4"),

    # Input fields for deleting a task
    dbc.Row([
        dbc.Col(dbc.Input(id="delete-task-input", placeholder="Task to delete...", type="text"), width=6),
        dbc.Col(dbc.Button("Delete Task", id="delete-task-btn", color="danger", n_clicks=0), width=2)
    ], className="mb-4"),

    # Timeline visualization
    dbc.Row([
        dbc.Col(html.H5("Task Timeline", className="text-light"), width=12),
        dbc.Col(html.Div(id="timeline-graph", children=create_timeline(schedule_df)), width=12)
    ]),

    # Footer
    dbc.Row(dbc.Col(html.P("Made with ‚ù§Ô∏è by a Pro Developer", className="text-center text-secondary"), width=12))
], fluid=True)

@app.callback(
    [Output("schedule-table", "children"), Output("timeline-graph", "children")],
    [Input("add-task-btn", "n_clicks"), Input("delete-task-btn", "n_clicks")],
    [State("task-input", "value"), State("date-input", "value"), State("time-input", "value"),
     State("desc-input", "value"), State("delete-task-input", "value")]
)
def update_schedule(add_clicks, delete_clicks, task, date, time, desc, task_to_delete):
    global schedule_df
    ctx = dash.callback_context

    if not ctx.triggered:
        return create_table(schedule_df), create_timeline(schedule_df)

    if ctx.triggered[0]['prop_id'] == 'add-task-btn.n_clicks' and task and date and time:
        add_task(task, date, time, desc)

    if ctx.triggered[0]['prop_id'] == 'delete-task-btn.n_clicks' and task_to_delete:
        delete_task(task_to_delete)

    return create_table(schedule_df), create_timeline(schedule_df)

if __name__ == "__main__":
    app.run_server()